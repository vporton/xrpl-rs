# xrpl_async-rs

_(The basics are almost fully done during the hackathon, but only
some request methods and transaction types are implemented, so the
library is not yet practically usable. It is anticipated that
XRPL Foundation will give a grant to implement all methods and types
and test them.)_

This is fully asynchronous XRPL client written in idiomatic Rust:

```rust
    let http_client = Client::new();
    let api = JsonRpcApi::new(http_client, "http://s1.ripple.com:51234/".to_owned());
    let response = account_info(api, &request).await.unwrap();
```

By fully asynchronous, I mean:
- Single async call not only for JsonRpcApi to receive the result of the call, but also single async call to WebSocketApi to receive the result of the call.
  The Rust API for JSON RPC and for WebSocket are the same.
- Multipage answers (with "marker") are single asynchronous stream.
- (not yet implemented, see `TODO.md`) asynchronous watching blockchain events (such as
  a transaction going approved by the network).

Example:
```rust
let request = ChannelsRequest {
    account: Address::decode("r9cZA1mLK5R5Am25ArfXFmqgNwjZgnfk59"),
    destination_account: None,
    ledger: Ledger::Validated,
    limit: None,   
};
let (response, mut paginator) = account_channels(&api, &request)?;
// Now `response` contains data from response.
// Now `paginator` is a stream that is able to traverse multiple pages.
```

Paginator is implemented using futures and streams.

Internally, `ChannelsRequest` is a type that is convertible to
`Request`. `Request` can be passed to `Api` trait method `call`, that
returns `Response` that is convertible to `ChannelsResponse`. And
similarly for other API methods.

Two implementations of `Api` method are provided:
* `JsonRpcApi`
* `WebSocketApi`

I use `serde` for JSON (de)serialization.

The transactions binary serialization is done using code that is
autogenerated using a `derive` macros from transaction structs and
`definitions.json` file.

Transactions are done as follows:
```rust
    let tx = PaymentTransaction {
        amount: Amount {
            value: 10.0,
            currency: "USD".to_string(),
            issuer: our_address.clone(),
        },
        destination: our_address,
        destination_tag: None,
        invoice_id: None,
        send_max: None,
        deliver_min: None,
        signature: None,
        public_key: None,
    };
    sign_and_submit(&api,
                    tx,
                    public_key,
                    our_secret,
                    true).await?;
```

More examples in the file `src/bin/manual_test.rs`.